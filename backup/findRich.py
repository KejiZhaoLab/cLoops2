#!/usr/bin/env python
#--coding:utf-8 --
"""
findRich.py

Find the regulatory interaction chromatin hook/hub (rich) based on border score for Trac-looping data   . 
Modified based on Directionality Index. 
Raw Directionality Index is:
DI =  (B-A) / (|B-A|) * ( (A-E)**2 + (B-E)**2 ) / E
E = (A+B)/2

Remove the direction and with E to simiplify the score is following:

BS = (A-B)*(A-B)/(A+B)

High BS is the border, some false positive can be removed requiring high local PETs or overlap with ATAC-seq peaks. 

2019-10-28: change the binsize and step to small number for Trac-looping data and increase the IS cutoffs for identificaiton of borders.
2019-11-03: change the insulation score to normalized one, the borders called will be more stable.  It should be noiticed, in Trac-looping, high insulation score, not low, more correlated with bordres.
2019-11-05: change the insulation score to border score.
"""

__date__ = "2019-10-27"
__modified__ = "2019-11-03"
__email__ = "caoyaqiang0410@gmail.com"

#general library
import os, argparse
from glob import glob
from collections import Counter
from datetime import datetime
from argparse import RawTextHelpFormatter

#3rd library
import numpy as np
import pandas as pd
from tqdm import tqdm

#cLoops2
from cLoops2.ds import XY
from cLoops2.io import parseIxy


def help():
    """
    Create the command line interface for the script.
    """
    description = """
        Find the regulatory interaction chromatin hook/hub (rich) regions 
        based on border score. Modified based on Directionality Index. 
        Output is a .txt file with border score, a .bed 
        file annotate the rich regions.
        Example:
        findRich.py -f GM12878_Trac/chr21-chr21.ixy -o GM12878_Trac_chr21
        """
    parser = argparse.ArgumentParser(description=description,
                                     formatter_class=RawTextHelpFormatter)
    parser.add_argument(
        "-f",
        dest="fixy",
        required=True,
        type=str,
        help=
        "Input .ixy file generated by cLoops2 to caculate insulation score.")
    parser.add_argument("-o",
                        dest="output",
                        required=True,
                        type=str,
                        help="Output prefix.")
    parser.add_argument(
        "-bs",
        dest="binSize",
        required=False,
        default=500,
        type=int,
        help="Bin size (bp) to caculate the border score, default is 500 bp.")
    parser.add_argument(
        "-pcut",
        dest="pcut",
        required=False,
        default=1000,
        type=int,
        help=
        "The distance cutoff to filter PETs, avoid bias of PETs located in peaks, default is 1000 bp."
    )
    parser.add_argument(
        "-cut",
        dest="cut",
        required=False,
        default=2,
        type=float,
        help=
        "The border score cutoff to determin the domain and borders, default is 2."
    )

    op = parser.parse_args()
    return op


def calcBS(f, fout, start=-1, end=-1, bs=500, pcut=1000):
    """
    Calculation of border score, output as .bedGraph file.
    """
    print("loading %s" % f)
    key, mat = parseIxy(f, cut=pcut)
    xy = XY(mat[:, 0], mat[:, 1])
    if key[0] != key[1]:
        print(
            "Border score can be only caculated for intra-chromosomal interactions. Return."
        )
        return
    if start == -1:
        start = np.min(xy.xs)
    if end == -1:
        end = np.max(xy.ys)
    bins = int((end - start) / bs)
    print("caculating from %s to %s of %s bins" % (start, end, bins))
    ds = []
    sa = []
    sb = []
    for i in tqdm(range(bins)):
        x = start + i * bs
        xclocal = xy.queryPeakBoth(x, x + bs)
        xctotal = xy.queryPeak(x, x + bs)
        if len(xctotal) == 0:
            continue
        xc = xctotal.difference(xclocal)
        smat = mat[list(xc), ]
        a = len(np.where(smat[:, 0] < x)[0])
        b = len(np.where(smat[:, 1] > x + bs)[0])
        if a + b == 0 or a - b == 0:
            continue
        di = (a - b) * (a - b) / (a + b)
        sa.append(di)
        sb.append(len(xctotal))
        ds.append([key[0], x, x + bs, di, 0, len(xclocal), len(xctotal), a, b])
    sa = np.array(sa)
    sa = np.log2(sa / np.mean(sa))
    sb = np.array(sb)
    sb = np.log2(sb / np.mean(sb))
    with open(fout + ".txt", "w") as fo:
        #header = "#chr\tstart\tend\tborderScore\tIS\tnormalizedLocalPETs\tlocalPETs\tallPETs\tupstreamPETs\tdownstreamPETs\n"
        #fo.write(header)
        for i in range(len(ds)):
            ds[i][3] = sa[i]
            ds[i][4] = sb[i]
            fo.write("\t".join(list(map(str, ds[i]))) + "\n")
    return ds


def findBorders(ds, fout, bscut=1, close=500):
    """
    Find rich borders. 
    """
    #find borders
    rs = []
    i = 0
    while i < len(ds):
        if ds[i][3] > bscut and ds[i][4] > bscut:
            p = i
            s = ds[i][3]
            j = i + 1
            while j < len(ds):
                if ds[j][3] > bscut and ds[j][4] > bscut:
                    if ds[j][1] - ds[j - 1][2] > close:
                        break
                    if ds[j][3] > s:
                        s = ds[j][3]
                        p = j
                    j = j + 1
                else:
                    break
            #get the region
            rs.append(
                [ds[i][0], ds[i][1], ds[j - 1][2], s, ds[p][1], ds[p][2]])
            i = j
        else:
            i = i + 1
    #stich borders
    nrs = []
    i = 0
    while i < len(rs):
        if i == len(rs) - 1:
            nrs.append(rs[i])
            break
        if rs[i + 1][1] - rs[i][2] > close:
            nrs.append(rs[i])
            i += 1
        else:
            p = i  #record the sumit
            for j in range(i + 1, len(rs)):
                if rs[j][1] - rs[j - 1][2] > close:
                    break
                if rs[j][3] > rs[p][3]:
                    p = j
            j = j - 1
            r = [rs[i][0], rs[i][1], rs[j][2], rs[p][3], rs[p][4], rs[p][5]]
            nrs.append(r)
            i = j + 1
    with open(fout + "_rich.bed", "w") as fo:
        for r in nrs:
            fo.write("\t".join(map(str, r)) + "\n")


def main():
    op = help()
    ds = calcBS(op.fixy, op.output, bs=op.binSize, pcut=op.pcut)
    findBorders(ds, op.output, bscut=op.cut, close=500)


if __name__ == "__main__":
    main()
