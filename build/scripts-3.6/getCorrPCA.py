#!/home/caoy7/anaconda2/envs/cLoops2/bin/python3
#--coding:utf-8 --
"""
getCorrPCA.py
Caculation the PC1 for correlation matrix of contact matrix. 
PCA1 + is activate compartment A, - is inactive compartment B. 

2019-12-07: created
2019-12-17: updated cmap
2020-08-20: modified as 0 signals position PCA1 as 0
"""


__date__ = "calcCorrPCA.py"
__modified__ = "2019-12-07"
__email__ = "caoyaqiang0410@gmail.com"

#general library
import os, argparse
from glob import glob
from collections import Counter
from datetime import datetime
from argparse import RawTextHelpFormatter

#3rd library
import numpy as np
import pandas as pd
from tqdm import tqdm
import matplotlib as mpl
from sklearn.decomposition import PCA
from matplotlib.colors import ListedColormap

#cLoops2
from cLoops2.ds import XY
from cLoops2.io import parsePet, parseIxy
from cLoops2.cmat import getObsMat, getExpMat
from cLoops2.settings import *


def help():
    """
    Create the command line interface for the script.
    """
    description = """
        Computate the correlation matrix for contact matirx and carry out PCA 
        analysis for the correlation matrix, output the PCA1 as bedgraph file, 
        and the correlation matrix as txt file.
        Example:
        getCorrPCA.py -f GM12878_Trac/chr21-chr21.ixy -o GM12878_Trac_chr21
        """
    parser = argparse.ArgumentParser(description=description,
                                     formatter_class=RawTextHelpFormatter)
    parser.add_argument("-f",
                        dest="fixy",
                        required=True,
                        type=str,
                        help="Input .ixy file generated by cLoops2.")
    parser.add_argument("-o",
                        dest="output",
                        required=True,
                        type=str,
                        help="Output prefix.")
    parser.add_argument(
        "-start",
        dest="start",
        required=False,
        default=-1,
        type=int,
        help=
        "Start genomic coordinate for the target region, default is the minmial corrdinate found in the file."
    )
    parser.add_argument(
        "-end",
        dest="end",
        required=False,
        default=-1,
        type=int,
        help=
        "End genomic coordinate for the target region, default is the maxmial corrdinate found in the file."
    )
    parser.add_argument(
        "-bs",
        dest="binSize",
        required=False,
        default=100000,
        type=int,
        help=
        "Bin size (bp) to generate the contact matrix, default is 50000 bp. Too small bin size may lead to out-of-memory problem."
    )
    parser.add_argument(
        "-cut",
        dest="cut",
        type=int,
        default=0,
        help="Distance cutoff for PETs to filter, default is 0.")
    parser.add_argument(
        "-hs",
        dest="hs",
        type=int,
        default=-1,
        help="The highlight region start site,default is -1, no highlight.")
    parser.add_argument(
        "-he",
        dest="he",
        type=int,
        default=-1,
        help="The highlight region end site, default is -1, no highlight.")

    op = parser.parse_args()
    return op


def calcCorrPCA(f, fout, r=50000, start=-1, end=-1, bs=50000, cut=0):
    """
    Computate the correlation matrix and carry out PCA.
    """
    chrom, xy = parseIxy(f, cut=cut)
    if chrom[0] != chrom[1]:
        return
    if start == -1:
        start = np.min(xy)
    if end == -1:
        end = np.max(xy)
    mat = getObsMat(xy, start, end, r)

    mat = np.log10(mat + 1)
    nmat = np.sum(mat,axis=0).astype("int")
    ps = np.where( nmat == 0)[0]
    mat = np.nan_to_num(mat)
    mat = np.corrcoef(mat)
    mat = np.nan_to_num(mat)
    #mat = mat - np.eye( mat.shape[0] ) #remove the diagnoal line

    #pca analysis
    pca = PCA(n_components=1)
    mat_r = pca.fit(mat.T).transform(mat.T)
    rs = np.array([t[0] for t in mat_r])
    rs[ps] = 0
    ss = np.arange(start, end + r, r)

    fig = pylab.figure(figsize=(2, 3))
    hr = [0.5, 2.4, 0.1]
    gs = mpl.gridspec.GridSpec(
        3,
        1,
        height_ratios=hr,
    )

    #plot PC1
    ax1 = fig.add_subplot(gs[0])
    pos = np.where(rs > 0)[0]
    neg = np.where(rs < 0)[0]
    #ax1.plot(ss[:-1], rs, color=colors[0])
    ax1.plot(ss[pos], rs[pos], color=colors[0], label="A")
    ax1.fill_between(ss[pos], rs[pos], color=colors[0])
    ax1.plot(ss[neg], rs[neg], color=colors[1], label="B")
    ax1.fill_between(ss[neg], rs[neg], color=colors[1])
    ax1.plot(ss, [0]*len(ss),color="k")
    ax1.legend(fontsize='x-small')
    ax1.set_ylabel("PC1", fontsize=6)
    ax1.set_xticklabels([])
    ax1.set_xlim([np.min(ss), np.max(ss)])
    ax1.set_ylim([np.min(rs), np.max(rs)])
    ax1.set_title(
        "%s:%s-%s\n%.2f kb,%s kb resolution" %
        (chrom[0], start, end, float(end - start) / 1000.0, r / 1000.0),
        fontsize=6)

    #plot heatmap and color bar
    ax2 = fig.add_subplot(gs[1])
    sns.set(font_scale=0.5)
    ax3 = fig.add_subplot(gs[2])
    cmap = sns.diverging_palette(250, 15, s=75, l=40, n=9).as_hex()
    cmap[int(len(cmap) / 2)] = "#FFFFFF"
    cmap = ListedColormap(cmap)
    ax2 = sns.heatmap(mat,
                      xticklabels=False,
                      yticklabels=False,
                      square=True,
                      center=0,
                      vmin=-1,
                      vmax=1,
                      ax=ax2,
                      cbar_ax=ax3,
                      cmap=cmap,
                      cbar_kws={
                          'label': "Pearson correlation coeificient",
                          'orientation': 'horizontal',
                          "shrink": 0.2,
                      })
    ax2.axvline(x=ax2.get_xlim()[0], color="k", linewidth=2)
    ax2.axvline(x=ax2.get_xlim()[1], color="k", linewidth=2)
    ax2.axhline(y=ax2.get_ylim()[0], color="k", linewidth=2)
    ax2.axhline(y=ax2.get_ylim()[1], color="k", linewidth=2)
    #output pc1 as bedgraph
    pylab.savefig(fout + "_compartments.pdf")
    with open(fout + "_comp_pc1.bdg", "w") as fo:
        for i in range(len(ss) - 1):
            line = [chrom[0], ss[i], ss[i + 1], rs[i]]
            line = "\t".join(list(map(str, line))) + "\n"
            fo.write(line)


def main():
    op = help()
    if op.start != -1 and op.end != -1 and op.end < op.start:
        print("ERROR! end %s is smaller than %s start." % (op.end, op.start))
    calcCorrPCA(op.fixy,
                op.output,
                r=op.binSize,
                start=op.start,
                end=op.end,
                bs=op.binSize,
                cut=op.cut)


if __name__ == "__main__":
    main()
